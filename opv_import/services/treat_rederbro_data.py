# coding: utf-8

# Copyright (C) 2017 Open Path View, Maison Du Libre
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <http://www.gnu.org/licenses/>.

# Contributors: Benjamin BERNARD <benjamin.bernard@openpathview.fr>
# Email: team@openpathview.fr
# Description: Handle all rederbor (camera and meta) data and save them using the APIs.

import logging
from path import Path
from typing import Callable
import errno
import os
from typing import List

from opv_api_client import ressources as OpvApiRes
from opv_api_client import RestClient as OpvApiRestClient

from opv_directorymanagerclient import DirectoryManagerClient

from opv_import import services
from opv_import import model

MAX_CONSECUTIVE_INCOMPLET_CAM_SETS = 35
ERROR_WINDOW_SIZE = 10
MAX_INCOMPLETE_SETS_IN_WINDOW = 4


class TreatRederbroData:

    def __init__(self,
                 cam_pictures_dir: Path,
                 id_malette: int,
                 opv_api_client: OpvApiRestClient,
                 opv_dm_client: DirectoryManagerClient,
                 number_of_cameras: int=6,
                 csv_meta_path: Path=None):
        """
        Initiate a treat rederbrodata instance with pictures directory and optionnaly a CSV.
        :param cam_pictures_dir: Where pictures are stored (DCIM folders)
        :param id_malette: Malette ID.
        :param opv_api_client: API client (used to save Lot ...).
        :param opv_dm_client: Directory Manager client.
        :param csv_meta_path: The meta CSV.
        """
        self.logger = logging.getLogger(TreatRederbroData.__module__ + "." + TreatRederbroData.__class__.__name__)
        self._cam_picture_dir = cam_pictures_dir
        self._csv_meta_path = csv_meta_path
        self._number_of_cameras = number_of_cameras

        # checking args
        if not self._cam_picture_dir.exists():
            raise FileNotFoundError(
                errno.ENOENT, os.strerror(errno.ENOENT), self._cam_picture_dir)
        if self._csv_meta_path is not None and not self._csv_meta_path.exists():
            raise FileNotFoundError(
                errno.ENOENT, os.strerror(errno.ENOENT), self._csv_meta_path)

        # -- Services
        self._lot_maker = services.LotMaker(pictures_path=self._cam_picture_dir,
                                            rederbro_csv_path=self._csv_meta_path,
                                            nb_cams=self._number_of_cameras)
        self._ress_manager = services.RessourceManager(opv_api_client=opv_api_client,
                                                       opv_dm_client=opv_dm_client,
                                                       id_malette=id_malette)

        # -- Data generated by the services
        self._meta_loaded = False  # tells if meta are loaded

        self._cam_set_generated = False  # tells if the camera sets where generated
        self._cam_sets = None  # Generated camera sets, will be a list of CameraSet

        self._lots_generated = False  # tells if lots are generated
        self._lots = None  # List of generated lots

        self._campaign = None
        self._campaign_created = False  # tells if the campaign for the current import is created

    def parse_metas(self):
        """ Parse CSV datas if a CSV is present. Lazy loading."""
        if not self._meta_loaded and self._csv_meta_path is not None:
            self.logger.debug("Parsing metas ...")
            self._lot_maker.load_metas()
            self._meta_loaded = True

    def generate_camera_sets(self, max_incomplete_camera_sets: int=MAX_CONSECUTIVE_INCOMPLET_CAM_SETS) -> List[model.ImageSet]:
        """
        Generate camera sets, lazy way.
        :param max_incomplete_camera_sets: Maxmum number of telerated consecutive incomplet sets.
        :return:
        """
        if not self._cam_set_generated:
            self.logger.debug("Generate camera images sets")
            self._lot_maker.load_cam_images()
            self._cam_sets = self._lot_maker.make_gopro_set_new(threshold_max_consecutive_incomplete_sets=max_incomplete_camera_sets)
            self._cam_set_generated = True
        return self._cam_set_generated

    def make_lot(self,
                 max_consecutive_incomplete_sets: int=MAX_CONSECUTIVE_INCOMPLET_CAM_SETS,
                 error_window_size: int=ERROR_WINDOW_SIZE,
                 max_incomplete_set_in_window: int=MAX_INCOMPLETE_SETS_IN_WINDOW) -> List[model.Lot]:  # no progression avaiable on it
        """ Make lots, generate all required datas also"""
        if not self._lots_generated:
            self.logger.debug("Generating lots ..")
            self.parse_metas()
            self.generate_camera_sets()

            if self._csv_meta_path is not None:  # when they are metas
                self._lots = self._lot_maker.generate_all_lot(
                    img_sets=self._cam_sets,
                    threshold_max_consecutive_incomplete_sets=max_consecutive_incomplete_sets,
                    threshold_incomplete_set_window_size=error_window_size,
                    threshold_incomplete_set_max_in_window=max_incomplete_set_in_window)
                self._lots_generated = True
            else:  # not meta, simply making lots
                self._lots = [model.Lot(cam_set=s, meta=None) for s in self._cam_sets]
                self._lots_generated = True
        return self._lots

    def create_campaign(self, name: str, id_rederbro: int, description: str="") -> OpvApiRes.Campaign:
        """
        Create a campaign. Lazy, return if already created.
        :param name:  Campaign name.
        :param id_rederbro: Id rederbro.
        :param description: Description of the campaign, default is null.
        :return: The created campaign.
        """
        if not self._campaign_created:
            self.logger.debug("Creating campaign")
            self._campaign = self._ress_manager.make_campaign(name=name, id_rederbro=id_rederbro, description=description)
            self._campaign_created = True
        return self._campaign

    def save_all_lot(self, on_progress_listener: Callable[[float], None]):
        """
        Save all lots.
        :param on_progress_listener: A lambda that will be executed when progression evolve, with the progression rate.
        :raises CampaignNeededException: You need a campaign to associated lot with it.
        """
        if not self._campaign_created:
            raise CampaignNeededException()

        nb_of_lots = len(self._lots)

        for i in range(0, len(self._lots)):
            lot = self._lots[i]
            self._ress_manager.make_lot(lot=lot, campaign=self._campaign)
            progression_rate = (i+1) / nb_of_lots
            on_progress_listener(progression_rate)

class CampaignNeededException(Exception):
    """ Campaign wasn't created. """
    pass